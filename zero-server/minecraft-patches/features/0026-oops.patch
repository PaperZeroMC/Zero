From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: oneachina <ruiruixi@hotmail.com>
Date: Sun, 1 Mar 2026 12:38:20 +0800
Subject: [PATCH] oops


diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index 14f30b828a9508debafccc6af44a2f29f2fe8068..d0cd499ec9f7d89dd03ee317522a25cfaa16c80d 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -124,10 +124,10 @@ public final class ChunkHolderManager {
         final List<NewChunkHolder> changedFullStatus = new ArrayList<>();
         final boolean ret;
         final ReentrantAreaLock.Node ticketLock = this.ticketLockArea.lock(
-                            ((chunkX >> ticketShift) - 1) << ticketShift,
-                            ((chunkZ >> ticketShift) - 1) << ticketShift,
-                            (((chunkX >> ticketShift) + 1) << ticketShift) | ticketMask,
-                            (((chunkZ >> ticketShift) + 1) << ticketShift) | ticketMask
+            ((chunkX >> ticketShift) - 1) << ticketShift,
+            ((chunkZ >> ticketShift) - 1) << ticketShift,
+            (((chunkX >> ticketShift) + 1) << ticketShift) | ticketMask,
+            (((chunkZ >> ticketShift) + 1) << ticketShift) | ticketMask
         );
         try {
             ret = this.processTicketUpdatesNoLock(chunkX >> ticketShift, chunkZ >> ticketShift, scheduledTasks, changedFullStatus);
@@ -147,7 +147,7 @@ public final class ChunkHolderManager {
     private boolean processTicketUpdatesNoLock(final int sectionX, final int sectionZ, final List<ChunkProgressionTask> scheduledTasks,
                                                final List<NewChunkHolder> changedFullStatus) {
         return this.ticketLevelPropagator.performUpdate(
-                sectionX, sectionZ, this.taskScheduler.schedulingLockArea, scheduledTasks, changedFullStatus
+            sectionX, sectionZ, this.taskScheduler.schedulingLockArea, scheduledTasks, changedFullStatus
         );
     }
 
@@ -332,9 +332,9 @@ public final class ChunkHolderManager {
                 if ((currTime - lastLog) > TimeUnit.SECONDS.toNanos(10L)) {
                     lastLog = currTime;
                     LOGGER.info(
-                            "Saved " + savedChunk + " block chunks, " + savedEntity + " entity chunks, " + savedPoi
-                                    + " poi chunks in world '" + WorldUtil.getWorldName(this.world) + "', progress: "
-                                    + format.format((double)(i+1)/(double)len * 100.0)
+                        "Saved " + savedChunk + " block chunks, " + savedEntity + " entity chunks, " + savedPoi
+                            + " poi chunks in world '" + WorldUtil.getWorldName(this.world) + "', progress: "
+                            + format.format((double)(i+1)/(double)len * 100.0)
                     );
                 }
             }
@@ -349,9 +349,9 @@ public final class ChunkHolderManager {
         }
         if (logProgress) {
             LOGGER.info(
-                    "Saved " + savedChunk + " block chunks, " + savedEntity + " entity chunks, " + savedPoi
-                            + " poi chunks in world '" + WorldUtil.getWorldName(this.world) + "' in "
-                            + format.format(1.0E-9 * (System.nanoTime() - start)) + "s"
+                "Saved " + savedChunk + " block chunks, " + savedEntity + " entity chunks, " + savedPoi
+                    + " poi chunks in world '" + WorldUtil.getWorldName(this.world) + "' in "
+                    + format.format(1.0E-9 * (System.nanoTime() - start)) + "s"
             );
         }
     }
@@ -766,13 +766,13 @@ public final class ChunkHolderManager {
         for (final PrimitiveIterator.OfLong iterator = this.tickets.keyIterator(); iterator.hasNext();) {
             final long coord = iterator.nextLong();
             sections.computeIfAbsent(
-                    CoordinateUtils.getChunkKey(
-                            CoordinateUtils.getChunkX(coord) >> sectionShift,
-                            CoordinateUtils.getChunkZ(coord) >> sectionShift
-                    ),
-                    (final long keyInMap) -> {
-                        return new LongArrayList();
-                    }
+                CoordinateUtils.getChunkKey(
+                    CoordinateUtils.getChunkX(coord) >> sectionShift,
+                    CoordinateUtils.getChunkZ(coord) >> sectionShift
+                ),
+                (final long keyInMap) -> {
+                    return new LongArrayList();
+                }
             ).add(coord);
         }
 
@@ -1235,7 +1235,7 @@ public final class ChunkHolderManager {
                             }
                             candidates.add(holder);
                         }
-                        
+
                         // Sort by usage count (ascending) and last access time (ascending)
                         candidates.sort((a, b) -> {
                             int usageCompare = Integer.compare(a.holderData.getUsageCount(), b.holderData.getUsageCount());
@@ -1244,7 +1244,7 @@ public final class ChunkHolderManager {
                             }
                             return Long.compare(a.holderData.getLastAccessTime(), b.holderData.getLastAccessTime());
                         });
-                        
+
                         // Take the first N chunks to unload
                         int len = toUnloadCount - processedCount;
                         for (int i = 0; i < len; ++i) {
@@ -1553,7 +1553,7 @@ public final class ChunkHolderManager {
         ret.add("tickets", allTicketsJson);
 
         for (final Iterator<ConcurrentLong2ReferenceChainedHashTable.TableEntry<TicketSet>> iterator = this.tickets.entryIterator();
-            iterator.hasNext();) {
+             iterator.hasNext();) {
             final ConcurrentLong2ReferenceChainedHashTable.TableEntry<TicketSet> coordinateTickets = iterator.next();
             final long coordinate = coordinateTickets.getKey();
             final TicketSet tickets = coordinateTickets.getValue();
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
index 6038bbe533073a893eda3378810c7646a5b2901f..90bd4cb1f323b0d2653876caaebc322ad81686f4 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
@@ -118,19 +118,19 @@ public final class ChunkTaskScheduler {
     private final PrioritisedTaskQueue mainThreadExecutor = new PrioritisedTaskQueue();
 
     public final ChunkHolderManager chunkHolderManager;
-    
+
     // Zero start - Chunk load queue management for load balancing
     private final AtomicInteger activeChunkLoads = new AtomicInteger(0);
     private static final int MAX_ACTIVE_CHUNK_LOADS = 64; // Maximum number of concurrent chunk loads
     private static final double MIN_TPS_FOR_FULL_LOAD = 18.0; // Minimum TPS for full load speed
-    
+
     private boolean canScheduleChunkLoad() {
         // Check current active chunk loads
         int currentLoads = this.activeChunkLoads.get();
         if (currentLoads >= MAX_ACTIVE_CHUNK_LOADS) {
             return false;
         }
-        
+
         // Check server TPS
         double tps = this.world.getServer().getCurrentSmoothedTickTime() < 50.0 ? 20.0 : 1000.0 / this.world.getServer().getCurrentSmoothedTickTime();
         if (tps < MIN_TPS_FOR_FULL_LOAD) {
@@ -141,15 +141,15 @@ public final class ChunkTaskScheduler {
                 return false;
             }
         }
-        
+
         return true;
     }
-    
+
     // Increment active chunk loads
     private void incrementActiveLoads() {
         this.activeChunkLoads.incrementAndGet();
     }
-    
+
     // Decrement active chunk loads
     private void decrementActiveLoads() {
         this.activeChunkLoads.decrementAndGet();
@@ -185,47 +185,47 @@ public final class ChunkTaskScheduler {
           for a status to be parallel safe it must not read the block data from its neighbours.
          */
         final List<ChunkStatus> parallelCapableStatus = Arrays.asList(
-                // No-op executor.
-                ChunkStatus.EMPTY,
+            // No-op executor.
+            ChunkStatus.EMPTY,
 
-                // This is parallel capable, as CB has fixed the concurrency issue with stronghold generations.
-                // Does not touch neighbour chunks.
-                ChunkStatus.STRUCTURE_STARTS,
+            // This is parallel capable, as CB has fixed the concurrency issue with stronghold generations.
+            // Does not touch neighbour chunks.
+            ChunkStatus.STRUCTURE_STARTS,
 
-                // Surprisingly this is parallel capable. It is simply reading the already-created structure starts
-                // into the structure references for the chunk. So while it reads from it neighbours, its neighbours
-                // will not change, even if executed in parallel.
-                ChunkStatus.STRUCTURE_REFERENCES,
+            // Surprisingly this is parallel capable. It is simply reading the already-created structure starts
+            // into the structure references for the chunk. So while it reads from it neighbours, its neighbours
+            // will not change, even if executed in parallel.
+            ChunkStatus.STRUCTURE_REFERENCES,
 
-                // Safe. Mojang runs it in parallel as well.
-                ChunkStatus.BIOMES,
+            // Safe. Mojang runs it in parallel as well.
+            ChunkStatus.BIOMES,
 
-                // Safe. Mojang runs it in parallel as well.
-                ChunkStatus.NOISE,
+            // Safe. Mojang runs it in parallel as well.
+            ChunkStatus.NOISE,
 
-                // Parallel safe. Only touches the target chunk. Biome retrieval is now noise based, which is
-                // completely thread-safe.
-                ChunkStatus.SURFACE,
+            // Parallel safe. Only touches the target chunk. Biome retrieval is now noise based, which is
+            // completely thread-safe.
+            ChunkStatus.SURFACE,
 
-                // No global state is modified in the carvers. It only touches the specified chunk. So it is parallel safe.
-                ChunkStatus.CARVERS,
+            // No global state is modified in the carvers. It only touches the specified chunk. So it is parallel safe.
+            ChunkStatus.CARVERS,
 
-                // FEATURES is not parallel safe. It writes to neighbours.
+            // FEATURES is not parallel safe. It writes to neighbours.
 
-                // no-op executor
-                ChunkStatus.INITIALIZE_LIGHT
+            // no-op executor
+            ChunkStatus.INITIALIZE_LIGHT
 
-                // LIGHT is not parallel safe. It also doesn't run on the generation executor, so no point.
+            // LIGHT is not parallel safe. It also doesn't run on the generation executor, so no point.
 
-                // Only writes to the specified chunk. State is not read by later statuses. Parallel safe.
-                // Note: it may look unsafe because it writes to a worldgenregion, but the region size is always 0 -
-                // see the task margin.
-                // However, if the neighbouring FEATURES chunk is unloaded, but then fails to load in again (for whatever
-                // reason), then it would write to this chunk - and since this status reads blocks from itself, it's not
-                // safe to execute this in parallel.
-                // SPAWN
+            // Only writes to the specified chunk. State is not read by later statuses. Parallel safe.
+            // Note: it may look unsafe because it writes to a worldgenregion, but the region size is always 0 -
+            // see the task margin.
+            // However, if the neighbouring FEATURES chunk is unloaded, but then fails to load in again (for whatever
+            // reason), then it would write to this chunk - and since this status reads blocks from itself, it's not
+            // safe to execute this in parallel.
+            // SPAWN
 
-                // FULL is executed on main.
+            // FULL is executed on main.
         );
 
         for (final ChunkStatus status : parallelCapableStatus) {
@@ -274,8 +274,8 @@ public final class ChunkTaskScheduler {
             ACCESS_RADIUS_TABLE_LOAD[i] = getAccessRadius0(status, ChunkPyramid.LOADING_PYRAMID);
             ACCESS_RADIUS_TABLE_GEN[i] = getAccessRadius0(status, ChunkPyramid.GENERATION_PYRAMID);
             ACCESS_RADIUS_TABLE[i] = Math.max(
-                    ACCESS_RADIUS_TABLE_LOAD[i],
-                    ACCESS_RADIUS_TABLE_GEN[i]
+                ACCESS_RADIUS_TABLE_LOAD[i],
+                ACCESS_RADIUS_TABLE_GEN[i]
             );
         }
         MAX_ACCESS_RADIUS = ACCESS_RADIUS_TABLE[ACCESS_RADIUS_TABLE.length - 1];
@@ -614,7 +614,7 @@ public final class ChunkTaskScheduler {
             }, priority);
             return;
         }
-        
+
         // Zero start - Load balancing
         if (!this.canScheduleChunkLoad()) {
             // Delay the chunk load if server is overloaded
@@ -624,7 +624,7 @@ public final class ChunkTaskScheduler {
             return;
         }
         // Zero end
-        
+
         final int accessRadius = getAccessRadius(toStatus);
         if (this.chunkHolderManager.ticketLockArea.isHeldByCurrentThread(chunkX, chunkZ, accessRadius)) {
             throw new IllegalStateException("Cannot schedule chunk load during ticket level update");
@@ -748,7 +748,7 @@ public final class ChunkTaskScheduler {
         }
 
         final Priority requestedPriority = Priority.max(
-                minPriority, chunkHolder.getEffectivePriority(Priority.NORMAL)
+            minPriority, chunkHolder.getEffectivePriority(Priority.NORMAL)
         );
         final ChunkStatus currentGenStatus = chunkHolder.getCurrentGenStatus();
         final ChunkAccess chunk = chunkHolder.getCurrentChunk();
@@ -784,8 +784,8 @@ public final class ChunkTaskScheduler {
         final ChunkStep chunkStep = chunkPyramid.getStepTo(toStatus);
 
         final int neighbourReadRadius = Math.max(
-                0,
-                chunkStep.getAccumulatedRadiusOf(ChunkStatus.EMPTY)
+            0,
+            chunkStep.getAccumulatedRadiusOf(ChunkStatus.EMPTY)
         );
 
         boolean unGeneratedNeighbours = false;
@@ -799,7 +799,7 @@ public final class ChunkTaskScheduler {
                 final ChunkStatus requiredNeighbourStatus = ((ChunkSystemChunkStep)(Object)chunkStep).moonrise$getRequiredStatusAtRadius(radius);
 
                 unGeneratedNeighbours |= this.checkNeighbour(
-                        chunkX + x, chunkZ + z, requiredNeighbourStatus, chunkHolder, allTasks, requestedPriority
+                    chunkX + x, chunkZ + z, requiredNeighbourStatus, chunkHolder, allTasks, requestedPriority
                 );
             }
         }
@@ -816,16 +816,16 @@ public final class ChunkTaskScheduler {
 
         final List<NewChunkHolder> chunkHolderNeighbours = new ArrayList<>((2 * neighbourReadRadius + 1) * (2 * neighbourReadRadius + 1));
         final StaticCache2D<GenerationChunkHolder> neighbours = StaticCache2D
-                .create(chunkX, chunkZ, neighbourReadRadius, (final int nx, final int nz) -> {
-                    final NewChunkHolder holder = nx == chunkX && nz == chunkZ ? chunkHolder : this.chunkHolderManager.getChunkHolder(nx, nz);
-                    chunkHolderNeighbours.add(holder);
+            .create(chunkX, chunkZ, neighbourReadRadius, (final int nx, final int nz) -> {
+                final NewChunkHolder holder = nx == chunkX && nz == chunkZ ? chunkHolder : this.chunkHolderManager.getChunkHolder(nx, nz);
+                chunkHolderNeighbours.add(holder);
 
-                    return holder.vanillaChunkHolder;
-                });
+                return holder.vanillaChunkHolder;
+            });
 
         final ChunkProgressionTask task = this.createTask(
-                chunkX, chunkZ, chunk, chunkHolder, neighbours, toStatus,
-                chunkHolder.getEffectivePriority(Priority.NORMAL)
+            chunkX, chunkZ, chunk, chunkHolder, neighbours, toStatus,
+            chunkHolder.getEffectivePriority(Priority.NORMAL)
         );
         allTasks.add(task);
 
@@ -908,7 +908,7 @@ public final class ChunkTaskScheduler {
             final long time = System.nanoTime();
             for (long failures = 9L;; failures = ConcurrentUtil.linearLongBackoff(failures, 500_000L, 50_000_000L)) {
                 if (
-                        !this.parallelGenExecutor.isActive() &&
+                    !this.parallelGenExecutor.isActive() &&
                         !this.loadExecutor.isActive()
                 ) {
                     return true;
@@ -930,7 +930,7 @@ public final class ChunkTaskScheduler {
             final long time = System.nanoTime();
             for (long failures = 9L;; failures = ConcurrentUtil.linearLongBackoff(failures, 500_000L, 50_000_000L)) {
                 if (
-                        !this.ioExecutor.isActive() &&
+                    !this.ioExecutor.isActive() &&
                         !this.saveExecutor.isActive() &&
                         !this.compressionExecutor.isActive()
                 ) {
@@ -1074,8 +1074,8 @@ public final class ChunkTaskScheduler {
 
     public static File getChunkDebugFile() {
         return new File(
-                new File(new File("."), "debug"),
-                "chunks-" + DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss").format(LocalDateTime.now()) + ".txt"
+            new File(new File("."), "debug"),
+            "chunks-" + DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss").format(LocalDateTime.now()) + ".txt"
         );
     }
 
diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index 9518e699e41df0e3101b98da7b317c439176767b..a0a422b5965e21f4669b23c6d9bb6bf8f345dd2f 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -324,7 +324,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             return null;
         }
         // Zero end
-        
+
         // Paper start - rewrite chunk system
         if (chunkStatus == ChunkStatus.FULL) {
             final LevelChunk ret = this.fullChunks.get(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(x, z));
@@ -339,12 +339,12 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         return this.getChunkFallback(x, z, chunkStatus, requireChunk);
         // Paper end - rewrite chunk system
     }
-    
+
     // Zero start - Chunk load request filtering
     private boolean shouldLoadChunk(int chunkX, int chunkZ) {
         // Check if there are any players nearby that might need this chunk
         double maxDistanceSquared = 64.0 * 64.0; // 64 blocks radius
-        
+
         for (ServerPlayer player : this.level.players) {
             ChunkPos playerChunk = player.chunkPosition();
             double distanceSquared = new ChunkPos(chunkX, chunkZ).distanceSquared(playerChunk);
@@ -352,10 +352,10 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 return true;
             }
         }
-        
+
         // Check if there are any entities that might need this chunk
         // (Optional: add entity checks here if needed)
-        
+
         return false;
     }
     // Zero end
